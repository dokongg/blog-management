---
layout:     post
title:      "Part 1-5. 데이터베이스"
date:       2021-05-12
categories: CS


---


1. **데이터베이스**   
   1.1. 데이터베이스를 사용하는 이유   
   1.2. 데이터베이스의 특징   
   1.3. 데이터베이스의 성능  


2. **Index**   
   2.1. Index란 무엇인가   
   2.2. Index의 자료구조   
   2.3. Primary index vs. Secondary index   
   2.4. Composite index   
   2.5. Index의 성능과 고려해야 할 사항   



3. **정규화**   
   3.1. 정규화의 탄생 배경  
   3.2. 정규화란 무엇인가   
   3.3. 정규화의 종류   


4. **Transaction**   
   4.1. 트랜잭션(Transaction)이란 무엇인가  
   4.2. 트랜잭션과 Lock     
   4.3. 트랜잭션의 특성  
   4.4. 트랜잭션의 상태
   4.5. 트랜잭션을 사용할 때 주의할 점  


5. **교착상태**   
   5.1. 교착상태란 무엇인가   
   5.2. 교착상태의 예시(Mysql)   
   5.3. 교착상태의 빈도를 낮추는 방법   

6. **Statement vs. PreparedStatement**   


7. **NoSQL**   
   7.1. NoSQL의 정의   
   7.2. CAP 이론   
   7.2. 저장 방식에 따른 분류

- - -

#### **1. 데이터베이스**   

##### **1.1. 데이터베이스를 사용하는 이유**   
- 데이터베이스가 존재하기 이전
  + 파일 시스템을 이용하여 데이터를 관리
  + 데이터를 각각의 파일 단위로 저장하며, 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동되어야 한다.
    + 데이터의 종속성 문제와 중복성, 데이터의 무결성 문제 발생


##### **1.2. 데이터베이스의 특징**
(1) 데이터의 독립성
 - 물리적 독립성: 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.
 - 논리적 독립성: 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시킬 수 있다.

(2) 데이터의 무결성
 - 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지
 - 데이터 유효성 검사를 통해 구현

(3) 데이터의 보안성
- 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정

(4) 데이터의 일관성
- 연관된 정보를 논리적인 구조로 관리함으로써, 어떠 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다.
- 작업 중 일부 데이터만 변경되기 때문에 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.

(5) 데이터 중복의 최소화
- 데이터를 통합하여 관리함으로써, 파일 시스템의 단점 중에 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.


##### **1.3. 데이터베이스의 성능**
- 디스크 I/O를 어떻게 줄이느냐에서 시작
  + 디스크 I/O: 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터를 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것
  + 데이터를 읽는 데 걸리는 시간: 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다.
    + 디스크의 성능은 디스크 헤더의 위치 이동없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다.
  + 순차 I/O가 랜덤 I/O보다 빠를 수 밖에 없다.
    + 쿼리 튜닝: 현실에서는 대부분의 I/O이 랜덤 I/O이기 때문에, 랜덤 I/O를 순차 I/O로 바꿔서 실행할 수 없을까라는 생각에서 시작하여, 랜덤 I/O 자체를 줄여주는 것



#### **2. Index**   
##### **2.1. Index란 무엇인가**
(1) 정의
- 책의 맨 처음 또는 맨 마지막에 있는 색인
  + 데이터: 책의 내용
  + 데이터가 저장된 레코드의 주소: 인덱스 목록에 있는 페이지의 번호
- 컬럼의 값과 해당 레코드아 저장된 주소를 키와 값의 쌍으로 만들어두는 것
  + DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져 오려면 시간이 오래 걸리기 때문

(2) 특징
- 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는 데에는 빠르지만, 새로운 값을 추가/삭제/수정하는 경우에는 쿼리문 실행 속도가 느려진다.
  + 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능
- `SELECT` 쿼리문의 `WHERE` 조건절에 사용되는 컬럼이라고 전부 인덱스로 생성하면, 데이터의 저장능력이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과 발생


##### **2.2. Index의 자료구조**
(1) B+-Tree 인덱스 알고리즘
- 일반적으로 사용되는 인덱스 알고리즘
- 컬럼의 값을 변형하지 않고(실제로는 값의 앞 부분만 잘라서 관리한다 원래의 값을 이용해 인덱싱하는 방법

(2) Hash 인덱스 알고리즘
- 컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘
- 값을 변형해서 인덱싱 하므로, 특정 문자로 시작하는 값으로 검색하는 전방 일치과 같이 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다.
- 주로 메모리 기반의 데이터베이스에서 많이 사용

(3) index 생성 시 B+-Tree 인덱스 알고리즘을 사용하는 이유
- `SELECT` 쿼리문의 조건에는 부등호(<>) 연산도 포함이 된다. Hash 인덱스 알고리즘의 경우, hash table을 사용하게 된다면, 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다.
  + 동등 연산(=)에 특화된 `hashtable`은 데이터베이스의 자료구조로 적합하지 않다.


##### **2.3. Primary index vs. Secondary index**
##### **2.4. Composite index**
##### **2.5. Index의 성능과 고려해야 할 사항**



#### **3. 정규화**   
##### **3.1. 정규화의 탄생 배경**  
##### **3.2. 정규화란 무엇인가**   
##### **3.3. 정규화의 종류**


#### **4. Transaction**

##### **4.1. 트랜잭션(Transaction)이란 무엇인가**  
- 작업의 완전성을 보장해주는 것
  + 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않도록 함
- 사용자의 입장에서는 논리적 단위로, 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위

##### **4.2. 트랜잭션과 Lock**     
(1) 트랜잭션
- 데이터의 정합성을 보장하기 위한 기능
- 반드시 여러 개의 변경 작업을 수행하는 쿼리가 조합되었을 때만 의미있는 개념은 아님
  + 하나의 논리적인 작업 셋 중 쿼리의 개수와는 상관없이 논리적인 작업 셋 자체가 100% 적용되거나 아무 것도 적용되지 않아야 함을 보장하는 것

(2) Lock
- 동시성을 제어하기 위한 기능
- 여러 커넥션에서 동시에 동일한 자원을 요청할 경우, 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 하는 역할
  + 자원: 레코드나 테이블


##### **4.3. 트랜잭션의 특성**  
ACID 원칙
(1) Atomicity: 원자성
- 트랜잭션 중간에 어떠한 문제가 발생한다면, 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안된다.
  + 아무런 문제가 발생하지 않았을 경우에만 수행되어야 한다.

(2) Consistency: 일관성
- 트랜잭션이 완료된 다음의 상태에서도 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

(3) Isolation: 고립성
- 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

(4) Durability: 지속성
- 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.

##### **4.4. 트랜잭션의 상태**  
![Alt Text](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/blob/master/Database/images/transaction-status.png?raw=true)   

(1) Active: 트랜잭션 활동 상태
- 트랜잭션이 실행 중이며, 동작 중인 상태

(2) Failed: 트랜잭션 실패 상태
- 트랜잭션을 더 이상 정상적으로 진행할 수 없는 상태

(3) Partially Committed: 트랜잭션의 `Commit` 명령이 도착한 상태
- 트랜잭션의 `Commit` 이전의 `sql`문이 수행되고, `Commit`만 남은 상태

(4) Commited: 트랜잭션 완료 상태
- 트랜잭션이 정상적으로 완료된 상태

(5) Aborted: 트랜잭션 취소 상태
- 트랜잭션이 취소되고 트랜잭션 실행 이전의 데이터로 돌아간 상태

> _**※ Partially Commited와 Commited의 차이점**_
1. `Partially Committed`
 - `Commit` 요청이 들어왔을 때
 - 이 후, `Commit`을 문제없이 수행할 수 있으면 `Commited` 상태, 만약 오류가 발생하면 `Failed` 상태가 된다.
2. `Commited`
 - `Commit`을 정상적으로 완료한 상태



##### **4.5. 트랜잭션을 사용할 때 주의할 점**  
- 트랜잭션의 범위를 최소화하여 적용한다.
  + 반드시 필요한 최소의 코드에만 적용하는 것이 좋다.
    + 일반적으로 데이터베이스 커넥션 개수는 제한적인데, 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 그 사용 가능한 여유 개수는 줄어들게 된다.
    + 어느 순간 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수 도 있다.


#### **5. 교착상태**
##### **5.1. 교착상태란 무엇인가**   
##### **5.2. 교착상태의 예시(Mysql)**   
##### **5.3. 교착상태의 빈도를 낮추는 방법**   

#### **6. Statement vs. PreparedStatement**   


#### **7. NoSQL**   
##### **7.1. NoSQL의 정의**   
##### **7.2. CAP 이론**
##### **7.2. 저장 방식에 따른 분류**



참고: <https://github.com/JaeYeopHan/Interview_Question_for_Beginner>
