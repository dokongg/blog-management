---
layout:     post
title:      "Part 1-5. 데이터베이스"
date:       2021-05-12
categories: CS


---


1. **데이터베이스**   
   1.1. 데이터베이스를 사용하는 이유   
   1.2. 데이터베이스의 특징   
   1.3. 데이터베이스의 성능  


2. **Index**   
   2.1. Index란 무엇인가   
   2.2. Index의 자료구조   
   2.3. Index의 종류   
   2.4. Clustered index   
   2.5. Index의 성능과 고려해야 할 사항   


3. **정규화**   
   3.1. 정규화의 탄생 배경  
   3.2. 정규화란 무엇인가   
   3.3. 정규화의 종류   
   3.4. 정규화의 장단점   
   3.5. 반정규화(De-normalization)


4. **Transaction**   
   4.1. 트랜잭션(Transaction)이란 무엇인가  
   4.2. 트랜잭션과 Lock     
   4.3. 트랜잭션의 특성  
   4.4. 트랜잭션의 상태   
   4.5. 트랜잭션을 사용할 때 주의할 점  


5. **교착상태**   
   5.1. 교착상태란 무엇인가   
   5.2. 교착상태의 예시(Mysql)   
   5.3. 교착상태의 빈도를 낮추는 방법   

6. **Statement vs. PreparedStatement**   
   6.1. java.sql.Statement   
   6.2. java.sql.PreparedStatement   

7. **NoSQL**   
   7.1. NoSQL의 정의   
   7.2. CAP 이론   
   7.2. 저장 방식에 따른 분류

- - -

#### **1. 데이터베이스**   

##### **1.1. 데이터베이스를 사용하는 이유**   
- 데이터베이스가 존재하기 이전
  + 파일 시스템을 이용하여 데이터를 관리
  + 데이터를 각각의 파일 단위로 저장하며, 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동되어야 한다.
    + 데이터의 종속성 문제와 중복성, 데이터의 무결성 문제 발생


##### **1.2. 데이터베이스의 특징**
(1) 데이터의 독립성
 - 물리적 독립성: 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.
 - 논리적 독립성: 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시킬 수 있다.

(2) 데이터의 무결성
 - 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지
 - 데이터 유효성 검사를 통해 구현

(3) 데이터의 보안성
- 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정

(4) 데이터의 일관성
- 연관된 정보를 논리적인 구조로 관리함으로써, 어떠 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다.
- 작업 중 일부 데이터만 변경되기 때문에 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.

(5) 데이터 중복의 최소화
- 데이터를 통합하여 관리함으로써, 파일 시스템의 단점 중에 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.


##### **1.3. 데이터베이스의 성능**
- 디스크 I/O를 어떻게 줄이느냐에서 시작
  + 디스크 I/O: 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터를 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것
  + 데이터를 읽는 데 걸리는 시간: 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다.
    + 디스크의 성능은 디스크 헤더의 위치 이동없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다.
  + 순차 I/O가 랜덤 I/O보다 빠를 수 밖에 없다.
    + 쿼리 튜닝: 현실에서는 대부분의 I/O이 랜덤 I/O이기 때문에, 랜덤 I/O를 순차 I/O로 바꿔서 실행할 수 없을까라는 생각에서 시작하여, 랜덤 I/O 자체를 줄여주는 것



#### **2. Index**   
##### **2.1. Index란 무엇인가**
(1) 정의
- 책의 맨 처음 또는 맨 마지막에 있는 색인
  + 데이터: 책의 내용
  + 데이터가 저장된 레코드의 주소: 인덱스 목록에 있는 페이지의 번호
- 컬럼의 값과 해당 레코드아 저장된 주소를 키와 값의 쌍으로 만들어두는 것
  + DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져 오려면 시간이 오래 걸리기 때문

(2) 특징
- 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는 데에는 빠르지만, 새로운 값을 추가/삭제/수정하는 경우에는 쿼리문 실행 속도가 느려진다.
  + 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능
- `SELECT` 쿼리문의 `WHERE` 조건절에 사용되는 컬럼이라고 전부 인덱스로 생성하면, 데이터의 저장능력이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과 발생


##### **2.2. Index의 자료구조**
(1) B+-Tree 인덱스 알고리즘
- 일반적으로 사용되는 인덱스 알고리즘
- 컬럼의 값을 변형하지 않고(실제로는 값의 앞 부분만 잘라서 관리한다 원래의 값을 이용해 인덱싱하는 방법

(2) Hash 인덱스 알고리즘
- 컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘
- 값을 변형해서 인덱싱 하므로, 특정 문자로 시작하는 값으로 검색하는 전방 일치과 같이 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다.
- 주로 메모리 기반의 데이터베이스에서 많이 사용

(3) index 생성 시 B+-Tree 인덱스 알고리즘을 사용하는 이유
- `SELECT` 쿼리문의 조건에는 부등호(<>) 연산도 포함이 된다. Hash 인덱스 알고리즘의 경우, hash table을 사용하게 된다면, 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다.
  + 동등 연산(=)에 특화된 `hashtable`은 데이터베이스의 자료구조로 적합하지 않다.

#### **2.3. Index의 종류**
- simple level index
- composite index
- multi level index

(1) Simple level Index   
![Alt Text](https://joosjuliet.github.io/images/2019-01-07-index/sparse_index.png)   
- 정렬되어 있기 때문에 이진 탐색에 좋다.
- `where key = 1003 인덱스가 걸린 컬럼의 where문 = (equality)(equality search)`이 빠르다.
- 메모리에 index table의 데이터 크기가 본 table의 것보다 작기 때문에 테이블을 탐색할 수 있는 양도 더 늘어나게 된다. 따라서 더 많은 양을 한 번에 탐색할 수 있기 때문에 탐색 시간이 단축된다.
- Primary Index(기본 인덱스): 인덱스를 primary key에 생성
- Secondary Index(보조 인덱스): 다른 컬럼에 인덱스를 생성

(2) Composite Index   
![Alt Text](https://joosjuliet.github.io/images/2019-01-07-index/composite_index.png)   
- 여러 개의 column에 indexing
- single index가 한 column에 indexing을 하는 것과 다르게 여러 개의 column에 indexing을 한다.
- 빈도 수가 적은 인덱스를 먼저 거는 게 좋다.
- 인덱스로 생성하는 필드의 속성이 중요하다.
  + title, author 이 순서로 인덱스를 설정한다면,
    + title을 search 하는 경우, index를 생성한 효과를 볼 수 있지만
    + author만으로 search 하는 경우, index를 생성한 것이 소용이 없어진다.
    + `SELECT` 질의를 어떻게 할 것인가가 인덱스를 어떻게 생성할 것인가에 많은 영향을 미친다.


(3) Multi Level Index   
![Alt Text](https://joosjuliet.github.io/images/2019-01-07-index/multilevel_index.png)   
- 인덱스 레벨이 많은 경우
- 인덱스를 위한 인덱스를 위한 ... 인덱스
- 데이터가 커지면 index 크기 역시 커진다.
  + 그러므로 single level index를 사용할 수 없어 multi level index를 사용한다.
- inner index(원래 인덱스)를 작은 색인으로 분할하여 outer index를 작게 만든다.
  + 이로 인해 I/O가 자주 일어나는 문제가 발생한다.
- 실제 데이터베이스 파일과 함께 디스크에 저장된다.


##### **2.4. Clustered index**
- 클러스터(Cluster): 여러 개를 하나로 묶는다는 의미로 주로 사용된다.
- 인덱스에서 클러스터드는 비슷한 것들을 묶어서 저장하는 형태로 구현된다.
  + 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안
  + 비슷한 값들은 물리적으로 인접한 장소에 저장되어 있는 데이터들을 말한다.
- 테이블의 프라이머리 키에 대해서만 적용되는 내용
  + 즉, 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것
  + 클러스터드 인덱스에서는 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며, 프라이머리 키 값이 변경되면 그 레코드의 물리적인 저장 위치까지 변경되어야 한다.
    + 그렇기 때문에 프라이머리 키를 신중하게 결정하고 클러스터드 인덱스를 사용해야 한다.
- 테이블 당 한 개만 생성할 수 있다.
  + 프라이머리 키에 대해서만 적용되기 때문
- 행 데이터를 인덱스로 지정한 열에 맞춰 자동 정렬한다.
- 테이블 생성 시 하나의 열에 Primary key를 쩡하면, 자동으로 클러스터형 인덱스가 생성된다.


##### **2.5. Index의 성능과 고려해야 할 사항**   
`SELECT` 쿼리의 `INDEX`가 항상 좋은 것은 아니다.
- `INDEX`를 생성하게 되면, `INSERT`, `DELETE`, `UPDATE` 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생한다.
  + `INSERT`: `INDEX`에 대한 데이터도 추가해야 하므로 그만큼 성능에 손실이 따른다.
  + `DELETE`: `INDEX`에 존재하는 값은 삭제하지 않고 사용하지 않는다는 표시로 남게 된다.
    + 즉, row의 수는 그대로이다.
    + 실제 데이터는 10만건인데, 데이터는 100만건이 있는 결과를 낳을 수도 있는 것이다. 이렇게 되면 인덱스는 더 이상 제 역할을 못하게 된다.
  + `UPDATE`: `INSERT`와 `DELETE`의 문제점을 수반하게 되어, 변경 전 데이터 삭제되지 않고 `INSERT`로 인한 split도 발생하게 된다.
- 컬럼을 이루고 있는 데이터의 형식에 따라 성능에 악영향을 미칠 수 있다.
  데이터의 형식에 따라 인덱스를 만들면 효율적인 것이 있고, 그렇지 않은 것이 있다.
    + `이름`, `나이`, `성별` 세 가지의 필드를 갖고 있는 테이블이 있다.
    + 이름: 온갖 경우의 수가 존재
    + 나이: INT 타입
    + 성별: 남/녀
  + 이름에 대해서만 인덱스를 생성하면 효율적이다.
    + 성별이나 나이에 대해 인덱스를 생성하면, 10000 레코드에 해당하는 테이블에 대해서 2000 단위로 성별을 인덱스를 생성했다고 가정했을 때 값의 range가 적은 성별은 인덱스를 읽고 다시 한 번 디스크 I/O가 발생하기 때문이다.


#### **3. 정규화**   
##### **3.1. 정규화의 탄생 배경**  
- 한 리레이션에 여러 Entity의 attribute를 혼합하게 되면 정보가 중복하여 저장되며, 저장 공간을 낭비하게 된다.
  + 중복된 정보는 갱신 이상을 일으킨다.
    + 동일한 정보를 한 릴레이션에는 변경하고, 나머지 릴레이션에서는 변경하지 않은 경우 어느 것이 정확한 지 알 수 없게 된다.


> **이상 현상(Anomaly)의 종류**
- 갱신 이상(Modification Anomaly)
  + 반복된 데이터 중에 일부를 갱신할 시, 데이터의 불일치가 발생하는 현상
- 삽입 이상(Insertion Anomaly)
  + 불필요한 정보를 함께 저장하지 않고서는 어떤 정보를 저장하는 것이 불가능한 경우
- 삭제 이상(Deletion Anomaly)
  + 필요한 정보를 삭제하지 않고서는 어떤 정보를 삭제하는 것이 불가능한 경우


##### **3.2. 정규화란 무엇인가**   
- 관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업
- 불만족스러운 나쁜 릴레이션의 attribute를 나누어서 좋은 작은 릴레이션으로 분해하는 작업
- 정규화 과정을 거치면 정규형을 만족하게 된다.
  + 정규형: 특정 조건을 만족하는 릴레이션의 스키마 형태(제 1 정규형, 제 2 정규형 등이 존재)   

(1) 나쁜 릴레이션을 파악하는 방법
- entity를 구성하고 있는 attribute 간에 함수적 종속성(Functional Dependency)을 판단
  + 판단된 함수적 종속성은 좋은 릴레이션 설계의 정형적 기준으로 사용된다.
  + 각각의 정규형마다 어떠한 함수적 종속성을 만족하는 지에 따라 정규형이 정의되고, 그 정규형을 만족하지 못하는 정규형을 나쁜 릴레이션으로 파악한다.   

(2) 함수적 종속성(Functional Dependency)
- attribute 데이터들의 의미와 attribute 간의 상호 관계로부터 유도되는 제약조건의 일종
- 정의: X와 Y를 임의의 attribute 집합이라고 할 때, X의 값이 Y의 값을 유일(unique)하게 결정한다면, `X는 Y를 함수적으로 결정한다`라고 한다.
- 실세계에서 존재하는 attribute 사이의 제약조건으로부터 유도된다.
- 각족 추론 규칙에 따라 attribute 간의 함수적 종속성을 판단할 수 있다.

(3) 정규형이 만족해야하는 조건
- 분해의 대상인 분해 집합 D는 무손실 조인을 보장해야 한다.
- 분해 집합 D는 함수적 종속성을 보존해야 한다.

> **무손실 분해(Lossy decomposition)**
- 하나의 릴레이션을 분해하고 다시 조인연산을 했을 때 데이터 손실이 없는 것


##### **3.3. 정규화의 종류**
(1) 제 1 정규형(1NF)
- attribute의 도메인이 오직 `원자값`만을 포함하고, tuple의 모든 attribute가 도메인에 속하는 하나의 값을 가져야 한다.
  + `원자값`: 각 로우마다 컬럼의 값이 1개씩만 있는 것
  + 복합 attribute, 다중값 attribute, 중첩 릴레이션 등 비 원자적인 attribute를 허용하지 않는 릴레이션 형태
- 관계형 데이터베이스의 테이블이 1NF이면, 최소한 테이블은 관계이며 중복되는 항목이 없어야 한다.
- 표준
  + 각 테이블에서 중복을 제거한다.
  + 각각 관계된 데이터 모임을 위하여 분리된 테이블을 만든다.
  + 각각 관계된 데이터 모임을 기본키로 식별한다.   

(2) 제 2 정규형(2NF)
- 모든 비주요 attribute가 주요 attribute에 대해서 완전 함수적 종속인 경우.
- 후보 키 K와 K에 속하지 않는 속성 A가 있을 때, A를 결정하기 위해 K의 일부가 아닌 K 전체를 참조해야만 하는 경우, 1NF 테이블은 2NF 이다.
  + 1NF 테이블은 복합 후보 키(한 개 이상의 속성들로 구성된 후보 키)가 없으면 자동으로 2NF이다.
- 테이블이 제 2 정규형을 만족하고, 테이블 내의 모든 속성이 기본 키에만 의존하며 다른 후보 키에 의존하지 않는다.

> **완전 함수적 종속**
- X -> Y 라고 가정했을 때, X의 어떠한 애트리뷰트라도 제거하면 더 이상 함수적 종속이 성립하지 않는 경우
- 키가 아닌 열들이 각각 후보키에 대해 결정되는 릴레이션

(3) 제 3 정규형(3NF)
- 어떠한 비주요 애트리뷰트도 기본키에 대해서 이행적으로 종속되지 않는 경우
- 기본 키 이외의 다른 컬럼이 그 외 다른 컬럼을 결정할 수 없다.

> **이행 함수적 종속**
- X -> Y, Y -> Z인 경우에 의해서 추론될 수 있는 X-> Z의 종속관계
- 비주요 애트리뷰트가 비주요 애트리뷰트에 의해 종속되는 경우가 없는 릴레이션

(4) BCNF(Boyce-Codd) 정규형
- 여러 후보 키가 존재하는 릴레이션에 해당하는 정규화
- 모든 결정자가 후보키 집합게 속한 정규형
- 복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제 3 정규형을 보완하는 데 의미가 있다.
- 비주요 애트리뷰트가 후보 키의 일부를 결정하는 분해하는 과정을 말한다.
  + 일반 컬럼이 후보키를 결정하지 않는 경우
- 조건
  + 모든 제 2 정규형 릴레이션은 제 1 정규형을 갖는다.
  + 모든 제 3 정규형 릴레이션은 제 2 정규형을 갖는다.
  + 모든 BCNF 정규형 릴레이션은 제 3 정규형을 갖는다.


##### **3.4. 정규화의 장단점**
(1) 정규화의 장점
- 데이터베이스 변경 시 이상 현상(Anomaly)을 제거할 수 있다.
- 데이터베이스 구조 확장 시 재 디자인을 최소화 할 수 있다.
  + 정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.
    + 데이터베이스와 연동된 응용 프로그램에 최소한의 영향만을 미치게 되며, 응용프로그램의 생명을 연장시킨다.
- 사용자에게 데이터 모델을 더욱 의미있게 제공한다.
  + 정규화된 테이블들 간의 관계들을 현실 세계에서의 개념들과 그 관계들을 반영한다.

(2) 정규화의 단점
- 릴레이션 분해로 인한 `JOIN` 연산이 많아진다.
  + 이로 인해, 질의에 대한 응답 시간이 느려질 수 있다.

##### **3.5. 반정규화(De-normalization)**
- 조회를 하는 SQL 문장에서 조인이 많이 발생하여 이로 인한 성능저하가 나타나는 경우에 반정규화를 적용하는 전략이 필요하다.   

(1) 반정규화(De-normalization, 비정규화)란
- 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법 중 하나이다.
- 반정규화가 필요한 경우
  + 디스크 I/O 량이 많아서 조회 시 성능이 저하된다.
  + 테이블끼리의 경로가 너무 멀어 조인으로 인한 성능저하가 예상된다.
  + 컬럼을 계산하여 조회할 때 성능이 저하될 것이 예상된다.
- 조회에 대한 처리 성능이 중요하다고 판단될 때 부분적으로 반정규화를 고려하게 된다.

(2) 반정규화의 대상
- 자주 사용되는 테이블에 액세스하는 프로세스의 수가 가장 많고 항상 일정한 범위만을 조회하는 경우
- 테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하여 성능상 이슈가 있는 경우
- 테이블에 지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 어려운 경우

(3) 반정규화 시 주의할 점
- 과도하게 적용하면 데이터의 무결성이 깨질 수 있다.
- 입력, 수정 삭제의 질문에 대한 응답 시간이 늦어질 수 있다.



#### **4. Transaction**

##### **4.1. 트랜잭션(Transaction)이란 무엇인가**  
- 작업의 완전성을 보장해주는 것
  + 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않도록 함
- 사용자의 입장에서는 논리적 단위로, 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위

##### **4.2. 트랜잭션과 Lock**     
(1) 트랜잭션
- 데이터의 정합성을 보장하기 위한 기능
- 반드시 여러 개의 변경 작업을 수행하는 쿼리가 조합되었을 때만 의미있는 개념은 아님
  + 하나의 논리적인 작업 셋 중 쿼리의 개수와는 상관없이 논리적인 작업 셋 자체가 100% 적용되거나 아무 것도 적용되지 않아야 함을 보장하는 것

(2) Lock
- 동시성을 제어하기 위한 기능
- 여러 커넥션에서 동시에 동일한 자원을 요청할 경우, 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 하는 역할
  + 자원: 레코드나 테이블


##### **4.3. 트랜잭션의 특성: ACID**  

(1) Atomicity: 원자성
- 트랜잭션 중간에 어떠한 문제가 발생한다면, 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안된다.
  + 아무런 문제가 발생하지 않았을 경우에만 수행되어야 한다.

(2) Consistency: 일관성
- 트랜잭션이 완료된 다음의 상태에서도 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

(3) Isolation: 고립성
- 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

(4) Durability: 지속성
- 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.

##### **4.4. 트랜잭션의 상태**  
![Alt Text](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/blob/master/Database/images/transaction-status.png?raw=true)   

(1) Active: 트랜잭션 활동 상태
- 트랜잭션이 실행 중이며, 동작 중인 상태

(2) Failed: 트랜잭션 실패 상태
- 트랜잭션을 더 이상 정상적으로 진행할 수 없는 상태

(3) Partially Committed: 트랜잭션의 `Commit` 명령이 도착한 상태
- 트랜잭션의 `Commit` 이전의 `sql`문이 수행되고, `Commit`만 남은 상태

(4) Commited: 트랜잭션 완료 상태
- 트랜잭션이 정상적으로 완료된 상태

(5) Aborted: 트랜잭션 취소 상태
- 트랜잭션이 취소되고 트랜잭션 실행 이전의 데이터로 돌아간 상태

> _**※ Partially Commited와 Commited의 차이점**_
1. `Partially Committed`
 - `Commit` 요청이 들어왔을 때
 - 이 후, `Commit`을 문제없이 수행할 수 있으면 `Commited` 상태, 만약 오류가 발생하면 `Failed` 상태가 된다.
2. `Commited`
 - `Commit`을 정상적으로 완료한 상태



##### **4.5. 트랜잭션을 사용할 때 주의할 점**  
- 트랜잭션의 범위를 최소화하여 적용한다.
  + 반드시 필요한 최소의 코드에만 적용하는 것이 좋다.
    + 일반적으로 데이터베이스 커넥션 개수는 제한적인데, 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 그 사용 가능한 여유 개수는 줄어들게 된다.
    + 어느 순간 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수 도 있다.


#### **5. 교착상태**
##### **5.1. 교착상태란 무엇인가**   
- 교착상태
  + 두 개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 상태에서 다른 트랜잭션이 소유하고 있는 잠금을 요구했을 때, 이를 아무리 기다려도 상황이 바뀌지 않는 상태
  + 복수의 트랜잭션 사용 시 발생

##### **5.2. 교착상태의 예시(Mysql)**   
- MySQL의 MVCC에 따른 특성 때문에 트랜잭션에서 갱신 연산(Insert, Update, Delete)를 실행하면 잠금을 획득하게 된다.

> **MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)**
- DBMS가 일반적으로 사용하는 동시성 제어 방식
- 데이터베이스로의 동시 접근을 제공하고 프로그래밍 언어에서 transactional memory를 구현한다.
- 동시성 제어가 없다면, 누군가가 데이터베이스를 읽는 동시에 다른 누군가가 기록을 하려고 하면 반쯤 기록되거나 일관성이 없는 데이터를 보게 될 가능성이 있다.
>
**1. 동시성 제어(Concurrency Control)**   
>   
> (1) 동시성 제어란?
- DBMS가 다수의 사용자 사이에서 동시에 작용하는 다중 트랜잭션의 상호간섭 작용에서 Database를 보호하는 것
- 동시성을 허용하면 일관성이 낮아지게 된다.   
![Alt Text](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FYYwAw%2FbtqAhqpozl2%2FIMdpfbgguBj897K4VkEwy1%2Fimg.png)   
- 다수 사용자의 동시 접속을 위해 DBMS는 동시성을 제어할 수 있도록 Lock 기능과 `SET TRANSACTION ON` 명령어를 이용해 트랜잭션의 격리수준(isolation)을 조정할 수 있는 기능 제공
>
(2) 동시성 제어의 목표
- 동시에 실행되는 트랜잭션 수를 최대화하면서 입력, 수정, 삭제, 검색 시 데이터의 무결성을 유지하는 데 있다.
  + Locking 메커니즘: 읽기 작업에 공유 Lock을 사용
>
(3) 동시성 제어 방법
- 비관적 동시성 제어(Pessimistic Concurrency Control)
  + 사용자들이 같은 데이터를 동시에 수정할 것이라고 가정
  + 데이터를 읽는 시점에 Lock을 걸고, 트랜잭션이 완료될 때까지 이를 유지
  + `SELECT` 시점에 `Lock`을 걸기 때문에, 시스템의 동시성을 심각하게 떨어뜨릴 수 있다.
    + `wait` 또는 `nowait` 옵션과 함께 사용해야 한다.
>
- 낙관적 동시성 제어(Optimistic Concurrency Control)
  + 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정
  + 데이터를 읽는 시점에 Lock을 걸지 않는 대신, 수정 시점에 값이 변경되었는 지를 반드시 검사한다.
>
(3) Locking 메커니즘의 문제점
- 읽기 작업과 쓰기 작업이 서로 방해를 일으키기 때문에 동시성 문제가 발생
- 데이터 일관성에 문제가 생기는 경우도 있어서 Lock을 더 오래 유지하거나 테이블 레벨의 Lock을 사용해야 하고, 동시성 저하 발생
- 이러한 문제를 해결하기 위해 MVCC 메커니즘이 탄생되었다.
>
**2. MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)**  
>
>(1) MVCC란
- 동시 접근을 허용하는 데이터베이스에서 동시성을 제어하기 위해 사용하는 방법 중 하나
- 데이터에 접근하는 사용자는 접근한 시점에서 데이터베이스의 Snapshot을 읽는다.
  + 이 snapshot 데이터에 대한 변경이 완료될 때(트랜잭션이 `commit` 될 때)까지 만들어진 변경사항은 다른 데이터베이스 사용자가 볼 수 없다.
  + 이제 사용자가 데이터를 업데이트하면 이전의 데이터를 덮어 씌우는 게 아니라, 새로운 버전의 데이터를 `UNDO` 영역에 생성한다.
     - 대신, 이전 버전의 데이터와 비교해서 변경되 내록을 기록한다.
     + 이렇게 해서 하나의 데이터에 대해 여러 버전의 데이터가 존재하게 되고, 사용자는 마지막 버전의 데이터를 읽게 된다.  
>     
(2) MVCC의 특징
- 일반적인 RDBMS 보다 매우 빠르게 작동
- 데이터 버전이 충돌하면 애플리케이션 영역에서 이러한 문제를 해결해야 한다.
- 데이터를 읽기 시작할 때, 다른 사람이 그 데이터를 삭제하거나 수정하더라도 영향을 받지 않고 데이터를 사용할 수 있다.
  + 대신, 사용하지 않는 데이터가 계속 쌓이게 되므로, 데이터를 정리하는 시스템 필요
- UNDO 블록 I/O, CR Copy 생성, CR 블록 캐싱과 같은 부가적인 작업의 오버헤드가 발생한다.
- 이러한 구조의 MVCC는 문장수준과 트랜잭션 수준의 읽기 일관성이 존재한다.


트랜잭션 1이 테이블 B의 첫 번째 행의 잠금을 얻고, 트랜잭션 2도 테이블 A의 첫 번째 행의 잠금을 얻었다고 하자.

![Alt Text](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/raw/master/Database/images/deadlock.png)


```sql
Transaction 1> create table B (i1 int not null primary key) engine = innodb;
Transaction2 2> create table A (i1 int not null primary key) engine = innodb;

Transaction 1> start transaction; insert into B values(1);
Transaction 2> start transaction; insert into A values(1);
```

트랜잭션을 commit 하지 않은 채 서로의 첫 번째 행에 대한 잠금을 요청하면, 아래와 같이 Deadlock이 발생한다.

```sql
Transaction 1> insert into A values(1);
Transaction 2> insert into B values(2);
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
```

##### **5.3. 교착상태의 빈도를 낮추는 방법**   
- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 접근한다.
  + 위에서 트랜잭션 1이 테이블 B -> A 의 순으로 접근했고, 트랜잭션 2는 테이블 A -> B 의 순으로 접근했다. 트랜잭션들이 동일한 테이블 순으로 접근하게 한다.
- 읽기 잠금 획득(`SELECT` ~ `FOR UPDATE`)의 사용을 피한다.
- 한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉽다.
  + 이 경우에는 테이블 단위의 잠금을 획득해 갱신을 직렬화하면, 동시성은 떨어지지만 교착상태를 회피할 수 있다.


#### **6. Statement vs. PreparedStatement**   
##### **6.1. java.sql.Statement**
- 정적 SQL 문을 실행하여, 작성된 결과를 돌려주기 위해 사용한다.
- `Statement` 객체마다 1개의 `ResultSet` 객체 만이 동시에 오픈 가능하다.
  + 따라서, 1개의 `ResultSet` 객체의 `read`에 다른 `read`가 끼어들면, 각각은 다른 `Statement` 객체에 의해 생성된 것이다.
- `Statement` 인터페이스의 모든 `execution` 메소드는 query의 현재 `ResultSet` 객체로 오픈된 것이 존재한다면 이를 암묵적으로 닫는다.

##### **6.2. java.sql.PreparedStatement**
- pre-compile 된 SQL 문을 나타내는 객체이다.
  + SQL 문은 pre-compile 되어 `PreparedStatement` 객체에 포함된다.
  + 이 객체는 query를 여러 차페 효율적으로 실행하는 목적으로 사용할 수 있다.
- `Statement` 보다 속도 면에서 더 빠르다.
  + 쿼리를 실행하기 전에 이미 쿼리가 컴파일되어 있으며, 반복 수행의 경우 프리 컴파일된 쿼리를 통해 수행이 이루어지기 때문
- 쿼리 자체에 조건이 들어가는 `dynamic sql`이 사용된다.
  + 파싱 타임을 줄여주는 것은 분명하지만, 이로 인해 performance 저하를 고려해야 한다.
  + 하지만, 성능을 고려할 때 시간 부분에서 가장 큰 비중을 차지하는 것은 테이블에서 레코드(row)를 가져오는 과정이며, SQL 문을 파싱하는 시간은 이 시간의 1/10에 불과하다.
- SQL Injection 등의 문제를 보완해준다.

#### **7. NoSQL**   
##### **7.1. NoSQL의 정의**   
(1) NoSQL이란   
- 관계형 데이터 모델을 지양하며, 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며, 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소   

(2) NoSQL의 특징   
- 종류마자 쓰기/읽기 성능 특화, 2차 인덱스 지원, 오토 샤딩 지원과 같은 고유한 특징을 지닌다.
- 대량의 데이터를 빠르게 처리하기 위해 메모리에 임시 저장하고 응답하는 등의 방법을 사용한다.
- 동적인 스케일 아웃을 지원하기도 하며, 가용성을 위해 데이터 복제 등의 방법으로 관계형 세이터베이스가 제공하지 못하는 성능과 특징을 제공한다.


##### **7.2. CAP 이론**
- Consistency: 일관성
- Availability: 가용성
- Partition tolerance: 네트워크 분할 허용성   

(1) Consistency: 일관성
- 다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터임을 보증하는 것
  + 일관성을 지원하지 않는 NoSQL을 사용한다면, 데이터의 일관성이 느슨하게 처리되어 동일한 데이터가 나타나지 않을 수 있다.
    + 느슨하게 처리된다는 것은 데이터의 변경을 시간의 흐름에 따라 여러 노드에 전파하는 것을 의미한다.
    + 최족적으로 일관성이 유지된다고 하여, 최종적 일관성 또는 궁극적 일관성을 지원한다고 한다.

- 데이터 동기화를 위해 사용하는 두 가지 방법
  + 동기식 방법: 데이터의 저장 결과를 클라이언트로 응답하기 전에 모든 노드에 데이터를 저장
    + 느린 응답 시간
    + 데이터의 정합성을 보장한다.
  + 비동기식 방법: 메모리나 임시 파일에 기록하고 클라이언트에 먼저 응답한 다음, 특정 이벤트 또는 프로세스를 사용하여 노드로 데이터를 동기화
    + 빠른 응답시간
    + 쓰기 노드에 장애가 발생했을 경우 데이터를 손실할 가능성이 있다.   

(2) Availability: 가용성
- 모든 클라이언트의 읽기와 쓰기 요청에 대하여 항상 응답이 가능해야 함을 보증하는 것(내고장성)
- 내고장성을 가진 NoSQL은 클러스터 내에서 몇 개의 노드가 망가지더라도 정상적인 서비스가 가능한다.
- 몇몇 NoSQL은 가용성을 보장하기 위해 데이터 복제(Replication)를 사용한다.
  + 동일한 데이터를 다중 노드에 중복 저장하여, 그 중 몇 대의 노드가 고장나도 데이터가 유실되지 않도록 하는 방법
  + 데이터 중복 저장 방법
    + Master-Slave 복제 방법: 동일한 데이터를 가징 저장소를 하나 더 생성하는 방법
    + Peer-to-Peer 복제 방법: 데이터 단위로 중복 저장하는 방법

(3) Partition tolerance: 네트워크 분할 허용성
- 지역적으로 분할된 네트워크 환경에서 동작하는 시스템에서 두 지역 간의 내트워크가 단절되거나 네트워크 데이터 유실이 일어나더라도 각 지역 내에 시스템은 정상적으로 동작해야 하는 것


##### **7.2. 저장 방식에 따른 분류**
- Key-Value Model
- Documnet Model
- Column Model
- Graph MOdel

(1) Key-Value Model
- 특징
  + 가장 기본적인 형태의 NoSQL
  + 키 하나로 데이터 하나를 저장하고 조회할 수 있는 단일 키-값 구조를 갖는다.
  + 단순한 저장구조로 인하여 복잡한 조회 연산은 지원하지 않는다.
  + 고속 읽기와 쓰기에 최적화된 경우가 많다.
- 활용
  + 사용자의 프로필 정보, 웹 서버 클러스터를 위한 세션 정보, 장바구니 정보, URI 단축 정보 저장 등
- 단점
  + 하나의 서비스 요청에 다수의 데이터 조회 및 수정 연산이 발생하면 트랜잭션 처리가 불가능하여 데이터 정합성을 보장할 수 없다.
- 예시
  + Redis   

(2) Document Model
- 특징
  + 키-값 모델을 개념적으로 확장한 구조
  + 하나의 키에 하나의 구조화된 문서를 저장하고 조회한다.
  + 논리적인 데이터 저장과 조회 방법이 관계형 데이터베이스와 유사하다.
  + 키는 문서에 대한 ID로 표현된다.
  + 저장된 문서를 컬렉션으로 관리하며, 문서 저장과 동시에 문서 ID에 대한 인덱스를 생성한다.
    + 문서 ID에 대한 인덱스를 사용하여 O(1) 시간 안에 문서를 조회할 수 있다.
  + B-tree 인덱스를 사용하여 2차 인덱스 생성
- 활용
  + 중앙 집중식 로그 저장, 타임 라인 저장, 통계 정보 저장 등
- 단점
  + 2차 인덱스 생성시 사용하는 B-tree 인덱스는 크기가 커질수록 새로운 데이터를 입력하거나 삭제할 때 성능이 저하된다.
    + 읽기와 쓰기 비율이 7:3 정도일 때 가장 좋은 성능을 보인다.   
- 예시
  + MongoDB   

(3) Column Model
- 특징
  + 하나의 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회한다.
  + 모든 컬럼은 항상 타임 스탬프 값과 함꼐 저장된다.
  + Row key, Column key, Column Family와 같은 빅테이블 개념이 공통적으로 사용된다.
  + 저장의 기본 단위는 컬럼으로, 컬럼은 컬럼 이름과 값, 타임스탬프로 구성된다.
    + 로우(Row): 이러한 컬럼들의 집합
    + 로우키(Row key): 각 로우를 유일하게 식별하는 값
    + 키 스페이스(Key Space): 이러한 로우들의 집합
  + 쓰기와 읽기 중 쓰기에 더 특화되어 있다.
  + 데이터를 먼저 커밋 로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답 속도를 제공한다.
    + 읽기 연산 대비 쓰기 연산이 많은 서비스나 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능을 보인다.
- 활용
  + 채팅 내용 저장, 실시간 분석을 위한 데이터 저장소 등의 서비스 구현
- 예시
  + 구글의 빅테이블


참고
- <https://github.com/JaeYeopHan/Interview_Question_for_Beginner>
- <https://mangkyu.tistory.com/53>
- <https://ko.wikipedia.org/wiki/다중_버전_동시성_제어>
- <https://celdee.tistory.com/312>
- <https://joosjuliet.github.io/index/>
- <https://mongyang.tistory.com/75>
- <https://wkdtjsgur100.github.io/anomaly/>
- <https://chokyuhwan.tistory.com/22>
- <https://ko.wikipedia.org/wiki/제1정규형>
- <https://ko.wikipedia.org/wiki/제2정규형>
- <https://ko.wikipedia.org/wiki/제3정규형>
- <https://3months.tistory.com/193>
