---
layout:     post
title:      "Part 1-7. 알고리즘"
date:       2021-05-26
categories: CS


---


1. **Sorting Algoritms**   
   1.1. 버블 정렬    
   1.2. 선택 정렬   
   1.3. 삽입 정렬   
   1.4. 병합 정렬   
   1.5. 힙 정렬   
   1.6. 퀵 정렬


- - -

#### **1. Sorting Algorithms**     

|종류|Best|Average|Worst|
|---|---|---|---|
|버블 정렬|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|
|선택 정렬|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|
|삽입 정렬|O(n)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|
|병합 정렬|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|
|힙 정렬|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|
|퀵 정렬|O(nlog<sub>2</sub>n)|O(nlog<sub>2</sub>n)|O(n<sup>2</sup>)|



##### **1.1. 버블 정렬**

(1) 개념
- n개의 원소를 가진 배열을 정렬할 때, In-place sort로 인접한 두 개의 데이터를 비교해가면서 정렬을 진행하는 방식
- 가장 큰 값을 배열의 맨 끝에다 이동시키면서 정렬하고자 하는 원소의 개수만큼을 두 번 반복하게 된다.   

(2) 특징
- 장점
  + 구현이 매우 간단하다.
- 단점
  + 순서에 맞지 않는 요소를 인접한 요소와 교환한다.
  + 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.
    + 특히, 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어난다.
  + 일반적으로 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 더 복잡하기 때문에 버블 정렬은 단순한 알고리즘에도 불구하고 거의 쓰이지 않는다.   

(3) 시간복잡도
- Best: O(n<sup>2</sup>)
- Average: O(n<sup>2</sup>)
- Worst: O(n<sup>2</sup>)


##### **1.2. 선택 정렬**

(1) 개념
- n개의 원소를 가진 배열을 정렬할 때, 계속해서 바꾸는 것이 아니라 비교하고 있는 값의 index를 저장해둔다. 그리고 최종적으로 한 번만 바꿔 준다.

(2) 특징
- 장점
  + 자료의 이동 횟수가 미리 결정된다.
- 단점
  + 안정성을 만족하지 않는다.
    + 값이 같은 레코드가 있다면 상대적인 위치가 변경될 수 있다.   

(3) 시간복잡도
- Best: O(n<sup>2</sup>)
- Average: O(n<sup>2</sup>)
- Worst: O(n<sup>2</sup>)


##### **1.3. 삽입 정렬**

(1) 개념
- n개의 원소를 가진 배열을 정렬할 때 i번째를 정렬할 순서라고 가정하면, 0부터 i-1까지의 원소들은 정렬되어있다고 가정한다. 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬한다.

(2) 특징
- 장점
  + 안전한 정렬 방법
  + 레코드의 수가 적을 경우 알고리즘 자체가 매우 간단하므로 다른 복잡한 정렬 방법보다 유리할 수 있다.
  + 대부분의 레코드가 이미 정렬되어 있는 경우에 매우 효율적일 수 있다.
- 단점
  + 비교적 많은 레코드들의 이동을 포함한다.
  + 레코드 수가 많고 레코드 크기가 클 경우에 적합하지 않다.   

(3) 시간복잡도
- Best: O(n)
- Average: O(n<sup>2</sup>)
- Worst: O(n<sup>2</sup>)


##### **1.4. 병합 정렬**

(1) 개념
- 정렬하고자 하는 배열의 크기를 작은 단위로 나누어, 정렬하고자 하는 배열의 크기를 줄이는 원리를 사용한다. Divide and conquer(분할정복)이라는 개념을 사용한다.

> **Divide and conquer(분할정복)**
- 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략
- 대게 순환 호출을 이용하여 구현한다.

(2) 특징
- 장점
  + 안정적인 정렬 방법
    + 데이터의 분포에 영향을 덜 받는다. 즉, 입력 데이터가 무엇이든 간에 정렬되는 시간은 O(nlog<sub>2</sub>n)으로 동일하다.
- 단점
  + 레코드를 배열(Array)로 구성하면, 임시 배열이 필요하다.
    + 제자리 정렬(in-place sorting)이 아니다.
  + 레코드들의 크기가 큰 경우에는 이동 횟수가 많으므로 매우 큰 시간적 낭비를 초래한다.

(3) 시간복잡도
- Best: O(nlog<sub>2</sub>n)
- Average: O(nlog<sub>2</sub>n)
- Worst: O(nlog<sub>2</sub>n)


##### **1.5. 힙 정렬**

(1) 개념
- 최대 힘 트리나 최소 힘 트리를 구성해 정렬하는 방법
- 내림차순 정렬을 위해서는 최대 힙을 구성하고, 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다.
- 과정
  + 정렬해야 할 n개의 요소들로 최대 힙(완전 이진 트리 형재)을 만든다.
    + 내림차순을 기준으로 정렬
  + 그 다음으로 한 번에 하나씩 요소를 힙에서 꺼내서 배열의 뒤부터 저장하면 된다.
  + 삭제되는 요소들(최댓값부터 삭제)은 값이 감소되는 순서대로 정렬되게 된다.

(2) 특징
- 장점
  + 시간 복잡도가 좋은 편이다.
  + 가장 유용한 경우는 전체 자료를 정렬하는 것이 아니라 가장 큰 몇 개의 값만 필요한 경우이다.

(3) 시간복잡도
- Best: O(nlog<sub>2</sub>n)
- Average: O(nlog<sub>2</sub>n)
- Worst: O(nlog<sub>2</sub>n)


##### **1.6. 퀵정렬**

(1) 개념
- 분할 정복 알고리즘의 하나로, 평균적으로 매우 빠른 수행 속도를 자랑하는 방법
  + 병합 정렬과 다르게 퀵 정렬은 리스트를 매우 비균등하게 분할한다.

(2) 특징
- 장점
  + 속도가 빠르다.
  + 추가 메모리 공간을 필요로 하지 않는다.
- 단점
  + 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
    + 퀵 정렬의 불균형 분할을 방지하기 위해 피벗을 선택할 때, 더욱 리스트를 균등하게 분할할 수 있는 데이터를 선택한다.
    + 리스트 내의 몇 개의 데이터 중에서 크기 순으로 중간 값(medium)을 피벗으로 선택한다.   

(3) 시간복잡도
- Best: O(nlog<sub>2</sub>n)
- Average: O(nlog<sub>2</sub>n)
- Worst: O(n<sup>2</sup>)



참고
- <https://github.com/JaeYeopHan/Interview_Question_for_Beginner>
- <https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html>
- <https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html>
- <https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html>
- <https://gmlwjd9405.github.io/2018/05/10/algorithm-heap-sort.html>
- <https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html>
